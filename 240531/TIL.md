# TIL (Today I Learned)

## 2024-05-31

### 주제: 프론트엔드 개발자 기술 면접

#### 리액트란 무엇인가요?
리액트(React)는 페이스북에서 개발한 오픈 소스 자바스크립트 라이브러리로, 사용자 인터페이스(UI)를 구축하는 데 사용됩니다. 리액트의 주요 특징은 다음과 같습니다:

- 컴포넌트 기반 아키텍처: 리액트는 UI를 재사용 가능한 컴포넌트로 나누어 개발할 수 있게 해줍니다.
- 가상 DOM(Virtual DOM): 리액트는 가상 DOM을 사용하여 실제 DOM 조작을 최소화하고, 성능을 최적화합니다.
- 단방향 데이터 흐름: 리액트는 데이터가 부모에서 자식으로 흐르는 단방향 데이터 흐름을 따릅니다.
- JSX: 리액트는 JSX(JavaScript XML)를 사용하여 자바스크립트 안에서 HTML과 유사한 문법을 사용할 수 있게 합니다.

#### 가상돔을 사용하면 좋은 이유?

- 가상 DOM은 애플리케이션 상태와 UI 간의 일관성을 유지하는 데 도움이 됩니다. 상태가 변경될 때마다 가상 DOM을 기반으로 UI를 다시 생성하므로, 애플리케이션의 상태와 UI가 항상 동기화된 상태를 유지합니다.
- 가상 DOM은 개발자가 선언적인 방식으로 UI를 작성할 수 있게 해줍니다. 개발자는 상태가 변경되었을 때 어떻게 UI를 업데이트할지 명시적으로 작성할 필요 없이, 새로운 상태에 맞게 UI를 정의하면 됩니다. 리액트가 상태 변경에 따라 자동으로 가상 DOM을 업데이트하고, 최적화된 방식으로 실제 DOM을 조작해줍니다.

#### RESTful API란? 

- RESTful API는 HTTP 프로토콜을 기반으로하는 웹 서비스 아키텍처입니다. 자원, 메소드, 메시지 등을 정의하여 클라이언트-서버 간의 통신을 가능하게 합니다. 또한, RESTful API는 표준 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 서버와 통신합니다.

#### HTTP Method는 무엇?

- GET: 서버에서 리소스(데이터)를 요청하는 메소드입니다. 요청한 데이터를 가져와 응답합니다.
- POST: 서버에 데이터를 전송하는 메소드입니다. 데이터를 전송하여 서버에서 처리하고, 처리 결과를 응답합니다.
- PUT: 서버에 데이터를 업데이트하는 메소드입니다. 요청한 데이터를 서버에 저장하고, 처리 결과를 응답합니다.
- DELETE: 서버에서 데이터를 삭제하는 메소드입니다. 요청한 데이터를 서버에서 삭제하고, 처리 결과를 응답합니다.

#### HTTP1.0, 2.0, 3.0에대한 주요 특징과 차이?

HTTP 1.0/1.x
- 지속적인 연결(Persistent Connections)을 도입하여 단일 TCP 연결을 통해 여러 요청을 처리합니다.
- 브라우저당 동시 연결 수에 제한이 있어 병렬 다운로드 속도가 제한될 수 있습니다.
- 요청 헤더에 Host 필드가 추가되어 가상 호스팅(Virtual Hosting)을 지원합니다.

HTTP 2.0
- 이진 프레임(binary framing)과 헤더 압축(header compression)을 통해 효율적인 데이터 전송을 지원합니다.
- 다중화(multiplexing)를 통해 하나의 TCP 연결로 여러 요청 및 응답을 병렬로 처리할 수 있습니다.
- 서버 푸시(server push)를 지원하여 클라이언트가 요청하지 않은 리소스를 미리 전송할 수 있습니다.
- 연결의 지연을 줄이고 대기 시간을 최소화하기 위해 선언적인 헤더를 사용합니다.

HTTP 3.0(완전 상용화 yet)
- QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 합니다.
- TCP 대신 UDP를 사용하여 통신하므로 연결 설정 및 관리에 대한 오버헤드를 줄일 수 있습니다.
- 다중화, 헤더 압축 및 서버 푸시와 같은 HTTP/2.0의 주요 기능을 유지하며, 더욱 효율적인 데이터 전송을 제공합니다.
- 연결을 확립하는 데 TCP보다 더 빠르고 안정적인 QUIC를 사용하여 대기 시간을 최소화합니다.
- HTTP/3.0은 현재 표준화 단계에 있으며, 대규모 웹 서비스에서의 사용이 점차 증가할 것으로 예상됩니다.

주요 차이점
- HTTP/1.x와 HTTP/2.0, HTTP/3.0의 가장 큰 차이는 데이터 전송 방식과 연결 관리 방식입니다.
- HTTP/1.x는 각각의 요청마다 별도의 TCP 연결을 생성하고 해제합니다. 반면에 HTTP/2.0와 HTTP/3.0은 단일 TCP 연결을 통해 여러 요청을 처리합니다.
- HTTP/2.0와 HTTP/3.0은 이진 프레임 및 헤더 압축과 같은 새로운 기술을 도입하여 효율적인 데이터 전송을 지원합니다.

#### CORS(Cross Origin Resource Sharing)란?
- 동일 출처 정책(Same Origin Policy): 기본적으로 브라우저는 스크립트에서 온 데이터 요청을 동일한 출처에서만 허용합니다. 이는 웹 애플리케이션이 악의적인 사이트에서 스크립트를 실행하여 사용자 데이터를 훔치는 것을 방지합니다.
- 다른 출처의 리소스에 접근할 때는 해당 출처의 서버에서 허용하는 경우에만 접근이 허용됩니다. 이를 위해 서버는 응답 헤더에 CORS 관련 정보를 포함하여 브라우저에게 허용 여부를 알려줍니다.

#### CORS 제어려하려면?
- 서버 측 CORS 정책 설정: 서버는 CORS를 허용할 출처를 명시하고, 이를 위한 응답 헤더를 설정합니다. 주로 Access-Control-Allow-Origin 헤더가 사용됩니다.
- 클라이언트 측 처리: 브라우저는 서버로부터의 응답 헤더를 확인하고, 요청이 허용되었을 경우에만 데이터를 처리합니다.

#### async/await란?
- async/await는 비동기적인 작업을 처리할 수 있는 ES2017 문법 입니다.
- async 함수를 정의하면 함수 내부에서 await 키워드를 이용하여 비동기적으로 처리되는 작업이 완료될 때까지 기다린 후, 결과값을 반환하는 처리를 할 수 있습니다.
- async/await는 Promise를 기반으로 하며, 코드를 보다 간결하고 직관적으로 작성할 수 있도록 해줍니다.
- async 함수는 항상 Promise 객체를 반환하며, await 키워드를 이용하여 비동기 처리 결과를 기다립니다.

#### 브라우저 렌더링 원리?
- HTML 파싱: 브라우저는 서버로부터 받은 HTML 문서를 파싱하여 DOM(Document Object Model) 트리를 생성합니다. DOM 트리는 문서의 구조를 표현하는 트리 구조로, 각 요소(Element)는 노드(Node)로 표현됩니다. (자바스크립트도 이때 실행됩니다.)
- CSS 파싱 및 스타일 계산: 브라우저는 HTML 문서의 <style> 태그나 외부 CSS 파일을 파싱하여 CSS 규칙을 해석하고, 각 요소의 스타일을 계산합니다. 이 과정에서 CSS 규칙의 우선순위에 따라 적용되는 스타일이 결정됩니다.
- 레이아웃(Layout) 생성: 스타일이 계산된 후, 브라우저는 각 요소의 위치와 크기를 계산하여 레이아웃을 생성합니다. 이 과정을 리플로우(Reflow)라고도 하며, HTML 요소의 배치와 크기를 결정하는 단계입니다.
- 렌더링 트리 생성: DOM 트리와 스타일 계산된 정보를 결합하여 렌더링 트리(Render Tree)를 생성합니다. 렌더링 트리는 화면에 실제로 표시되는 요소들을 포함하며, 시각적으로 표현될 요소들로 구성됩니다.
- 페인팅(Paint): 렌더링 트리를 기반으로 브라우저는 화면에 각 요소를 그립니다. 이 과정을 페인팅이라고 하며, 브라우저가 화면에 픽셀을 그리는 단계입니다.
- 합성(Compositing): 브라우저는 각 요소의 레이어를 결합하여 최종 화면을 생성합니다. 이 과정에서 불필요한 레이어를 최적화하고, 화면을 캐싱하여 성능을 향상시킵니다.

#### 웹 접근성과 웹 표준이란?

웹 접근성
- 장애인 및 고령자를 위한 적절한 조치: 시각, 청각, 운동, 인지 및 기타 장애를 가진 사용자들도 웹 사이트를 쉽게 이용할 수 있도록 조치가 취해집니다.
- 다양한 디바이스 및 브라우저 지원: 다양한 디바이스(모바일 기기, 스마트폰, 태블릿 등) 및 웹 브라우저(Chrome, Firefox, Safari, Edge 등)에서 웹 사이트가 잘 동작하도록 보장됩니다.
- 명료한 콘텐츠: 텍스트는 명확하게 표시되며, 이미지에 대한 대체 텍스트가 제공됩니다. 또한, 텍스트 크기를 조절할 수 있는 기능이 제공되어 시각 장애를 가진 사용자들이 콘텐츠를 쉽게 읽을 수 있습니다.
- 키보드 사용 지원: 마우스 없이 키보드만을 사용하여 웹 사이트를 탐색하고 상호 작용할 수 있도록 지원됩니다.
- 웹 접근성 표준 준수: 웹 콘텐츠 접근성 지침(WCAG, Web Content Accessibility Guidelines)과 같은 국제 표준에 따라 웹 사이트가 설계되고 개발됩니다.

웹표준
- 다양한 플랫폼 및 브라우저 호환성: 웹 표준을 준수하는 웹 사이트는 다양한 플랫폼 및 브라우저에서 일관되게 표시됩니다.
- 검색 엔진 최적화(SEO): 검색 엔진은 웹 표준을 준수하는 웹 사이트를 더 쉽게 색인화하고 인덱싱할 수 있습니다.
- 유지 보수 용이성: 웹 표준을 준수하는 웹 사이트는 코드의 일관성이 유지되며, 향후 유지 보수 및 업데이트가 용이합니다.
- 보안 강화: 웹 표준을 준수하는 웹 사이트는 보안 취약점을 최소화하고, 보안성을 강화할 수 있습니다.


#### 호이스팅이란?
- 호이스팅은 자바스크립트가 실행될 때, 변수와 함수 선언이 스코프(scope)의 최상단으로 올려져 실행되는 것을 의미합니다. 이로 인해 선언 전에 사용하는 경우 오류가 발생할 수 있습니다 ( Temporal Dead Zone).
```
// var
console.log(a); // undefined
var a = 10;
console.log(a); // 10

// let
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;

// const
console.log(c); // ReferenceError: Cannot access 'c' before initialization
const c = 30;

```

#### 클로저란?
- 함수가 선언될 때 자동으로 생성되는 렉시컬 환경에 대한 설명입니다.
- 이러한 렉시컬 환경은 스코프 체인(scope chain)을 형성하게 되는데, 스코프 체인은 함수가 선언될 때의 모든 변수와 함수를 포함하는 렉시컬 스코프(lexical scope)를 형성합니다.
- 외부 함수가 실행 되고 반환된 후에도 외부 함수의 범위 내의 함수에 체이닝을 할 수 있는 함수 입니다. 정보를 은닉하기 위해서 주로 사용 합니다.
```
function outer() {
    const outerVal = 'outer';

    function inner() {
        console.log(outerVal)
    }
    return inner
}
const excute = outer();
inner(); // 'outer'

```

#### 클래스형 컴포넌트와 함수형 컴포넌트의 차이?

- 리액트에서 컴포넌트를 만드는 방법에는 클래스형 컴포넌트(class components)와 함수형 컴포넌트(functional components)가 있습니다. 
- 클래스형 컴포넌트는 ES6의 클래스(class)를 사용하여 컴포넌트를 정의합니다. 이 방식은 React의 컴포넌트의 상태(state)와 생명주기(lifecycle)를 다룰 때 매우 유용합니다.
- 함수형 컴포넌트는 ES6의 화살표 함수(arrow function)를 사용하여 컴포넌트를 정의합니다. 이 방식은 훅(hook) API와 함께 많이 사용되며, 컴포넌트의 상태와 생명주기를 다룰 때도 유용합니다.
- 클래스형 컴포넌트는 상태를 this.state로 정의하고, 생명주기 메서드를 오버라이드하여 다양한 작업을 수행합니다.
- 함수형 컴포넌트는 상태를 useState 훅을 사용하여 정의하고, useEffect 훅을 사용하여 생명주기를 다룹니다. 또한, 클래스형 컴포넌트에서는 this 키워드를 사용하여 상태나 메서드를 참조하며, 함수형 컴포넌트에서는 this 키워드를 사용하지 않습니다.

#### 자바스크립에서 this란?

- 전역 객체(Global Object): 전역 스코프에서 사용되는 this는 전역 객체를 가리킵니다. 브라우저에서는 window 객체가 전역 객체이고, Node.js에서는 global 객체가 전역 객체입니다.
- 함수 내부: 함수가 일반 함수로 호출되었을 때, this는 전역 객체를 참조합니다. 하지만 엄격 모드(strict mode)에서는 함수 내부에서 this를 사용하면 전역 객체가 아니라 undefined가 됩니다.
- 메소드 내부: 객체의 메소드로 호출되었을 때, this는 해당 메소드를 호출한 객체를 참조합니다.
- 생성자 함수 내부: 생성자 함수로 호출되었을 때, this는 새로 생성된 인스턴스를 가리킵니다.
- 함수 내부에서 call 또는 apply로 명시적으로 지정된 경우: call 또는 apply 메소드를 사용하여 함수를 호출할 때, 첫 번째 매개변수로 전달된 객체가 this를 가리킵니다.
- 화살표 함수 내부: 화살표 함수는 자신만의 this를 가지지 않고, 상위 스코프의 this를 그대로 이용합니다.


#### 비동기 함수란?
- 비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다.
- 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환합니다. 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며, Promise 객체는 비동기 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 객체입니다.
- 비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용합니다.
- 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요합니다.
- 여러개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 
- 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다.
- 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어됩니다.

#### 이벤트루프란?
- 자바스크립트의 이벤트 루프(Event Loop)는 비동기적인 작업을 관리하고 실행하는 메커니즘입니다. 
- 이벤트 루프는 단일 스레드로 동작하는 자바스크립트에서 비동기 작업을 효율적으로 처리하기 위해 사용됩니다.
- 싱글 스레드 환경에서 비동기 작업 관리: 자바스크립트는 기본적으로 단일 스레드 환경에서 동작합니다. 하지만 비동기 작업이 필요한 경우가 많은데, 이를 효율적으로 처리하기 위해 이벤트 루프가 사용됩니다.
- 이벤트 및 콜백 함수 처리: 자바스크립트는 이벤트 및 콜백 함수를 통해 비동기 작업을 처리합니다. 이벤트 루프는 이러한 이벤트와 콜백 함수를 큐(Queue)에 추가하고, 이를 순서대로 실행하여 비동기적인 작업을 처리합니다.
- 동시성을 위한 비동기 작업 처리: 자바스크립트는 이벤트 루프를 통해 비동기 작업을 동시에 처리할 수 있습니다. 이벤트 루프는 메인 스레드에서 동기적으로 처리할 수 없는 작업을 다른 스레드나 외부 리소스에 위임하여 동시성을 활용합니다.


